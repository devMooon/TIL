# 논리 주소 공간과 실행 모드 개념

<br>

## <h2 style="color: red;">***Details***

## 응용 프로그램의 자원 접근 문제
- 다중프로그래밍 OS에서는 다수의 app 동시 실행
- app이 직접 컴퓨터 자원에 접근하면 충돌 혹은 훼손 발생 가능
    - 다른 app이 적재된 메모리 훼손
    - 다른 app이 생성한 파일 훼손
    - app이 커널 적재된 영역 훼손

<br>

## 응용 프로그램의 자원 접근 문제의 해결책
- 응용 프로그램의 자원 접근 불허
    - 자원에 대한 접근 커널에게만 부여
- 메모리 주소 공간을 분리
    - 사용자 주소 공간: 응용 프로그램 적재
    - 커널 주소 공간: 커널 적재
- CPU 실행 모드를 분리
    - 사용자 모드: 응용 프로그램 실행
        - 커널 기능 필요시 시스템 호출 이용(간접적으로 이용)
    - 커널 모드: 커널 코드 실행

<br>

## 논리 주소 공간: 사용자 공간과 커널 공간
- 논리 주소 공간: CPU가 접근하는 주소 범위
    - 사용자 주소 공간(user space)
        - 각 응용 프로그램이 나뉘어 적재되고 사용되는 공간
    - 커널 주소 공간(kernel space)
        - 커널에 의해 배타적으로 사용
            - 커널 코드, 커널 데이터, 디바이스 드라이버 등
- 분리 이유
    - 커널 코드/데이터를 app에서 부적절하게 접근하지 못하도록 하기 위해

> 주소 공간은 가상 주소 공간이다!
- 주소 공간은 물리 메모리 주소 범위와 무관
    - 사용자/app 관점에서 보는 주소 범위
        - 물리적인 실제 메모리 주소 범위와는 무관
    - 각 사용자/app은 전체 메모리를 사용한다 착각

<br>

## CPU의 실행모드: 사용자 모드와 커널 모드
- CPU는 '모드 레지스터'를 통해 현재 모드 식별
    - 사용자 모드(user mode)
        - 사용자 주소 공간만 접근 가능
        - 커널 주소 공간 접근 불허
        - 특권 명령(privileged instruction) 실행 불허

        > 예외 발생 후 강제 종료

    - 커널 모드(kernel mode, supervisor mode)
        - 모든 주소 공간 접근 가능
        - 특권 명령 실행 가능
        - HW 접근 제어 가능

<br><br>

## ***실행 모드와 관련된 다양한 이슈***

<hr>

**사용자 모드와 커널 모드는 누구의 기능인가?**
 - CPU의 기능(모드 레지스터)이다.

**OS가 모드를 구분해 작동하는 이유는?**
- 커널 공간(코드와 데이터)에 대한 보안/보호
    - 실수/고의로 인한 접근으로부터 보호
    - app에서 오류 발생시 시스템에 영향을 주지 못함

**app이 커널 코드를 호출할 수 있는가?**
- 불가, 반드시 시스템 호출을 통해 간접 호출해야함

**어느 모드가 많이 사용될까?**
- 커널 모드(예: system idle process 등)